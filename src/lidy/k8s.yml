main: root

root:
  _map:
    apiVersion: string
    kind: string
  _mapFacultative:
    metadata: metadata
    spec:
      _oneOf:
        - deploymentSpec
        - podSpec
        - serviceSpec
        - ingressSpec
        - configMapSpec
        - secretSpec
        - persistentVolumeClaimSpec

# spec:
#   _oneOf:
#     - simpleSpec
#     - compoundSpec

# simpleSpec:
#   _oneOf:
#     - podSpec
#     - serviceSpec
#     - ingressSpec
#     - configMapSpec
#     - secretSpec

# compoundSpec: # special cases: spec containing multiple components
#   _oneOf:
#     - deploymentSpec # Deployments and their Pod template are treated as separate components

########## CALLBACKS ###########################################################

uint16: int

########## COMMON STRUCTS (to reuse in SPECS) ##################################

metadata:
  _mapFacultative:
    name: string
    namespace: string
    labels:
      _mapOf: { string: string }
    annotations:
      _mapOf: { string: string }

labelSelector:
  _mapFacultative:
    matchLabels:
      _mapOf: { string: string }
    matchExpressions:
      _map:
        key: string
        operator:
          _in: ["In", "NotIn", "Exists", "DoesNotExist"]
      _mapFacultative:
        values:
          _listOf: string


########## SPECS (used for type/structure checks only) #########################

deploymentSpec:
  _mapFacultative:
    replicas: int
    selector: labelSelector
    template:
      _mapFacultative:
        metadata: metadata
        spec: podSpec

podSpec:
  _mapFacultative:
    containers:
      _listOf:
        _mapFacultative:
          name: string
          image: string
          ports:
            _listOf:
              _mapFacultative:
                containerPort: uint16

serviceSpec:
  _mapFacultative:
    type:
      _in: ["ClusterIP", "NodePort", "LoadBalancer", "ExternalName"]
    selector:
      _mapOf: { string: string }
    ports:
      _mapFacultative:
        name: string
        protocol:
          _in: ["TCP", "UDP", "SCTP"]
        targetPort: string # improvement: if the target port is a string, check that the port exists in the pod
      _map:
        port: uint16
    clusterIP: string
    externalName: string
    sessionAffinity: string
    sessionAffinityConfig:
      _mapFacultative:
        clientIP:
          _mapFacultative:
            timeoutSeconds: int
    clusterIPs:
      _listOf: string
    allocateLoadBalancerNodePorts: boolean
    externalIPs:
      _listOf: string
    externalTrafficPolicy: string
    healthCheckNodePort: uint16
    internalTrafficPolicy: string
    ipFamilies:
      _listOf: string
    ipFamilyPolicy: string
    loadBalancerClass: string
    loadBalancerSourceRanges:
      _listOf: string
    publishNotReadyAddresses: boolean
    loadBalancerIP: string

ingressSpec:
  _mapFacultative:
    todo: string

configMapSpec:
  _mapFacultative:
    data:
      _mapOf: { string: string }
    binaryData:
      _mapOf: { string: string }
    immutable: boolean

secretSpec:
  _mapFacultative:
    type:
      _in: ["Opaque", "kubernetes.io/service-account-token", "kubernetes.io/dockercfg", "kubernetes.io/dockerconfigjson", "kubernetes.io/basic-auth", "kubernetes.io/ssh-auth", "kubernetes.io/tls", "bootstrap.kubernetes.io/token"]
    stringData:
      _mapOf: { string: string }
    data:
      _mapOf: { string: string }
    immutable: boolean

persistentVolumeClaimSpec:
  _mapFacultative:
    storageClassName: string
    accessModes:
      _listOf:
        _in: ["ReadWriteOnce", "ReadWriteMany", "ReadWriteOncePod", "ReadOnlyMany"]
    volumeMode:
      _in: ["Filesystem", "Block"]
    resources:
      _mapFacultative:
        limits:
          _mapOf: { string: string }
        requests:
          _mapOf: { string: string }
    volumeName: string
    selector: labelSelector

